require("tidyverse")

# ---- Read the data ----
df <- read_csv("USA_INVESTMENT_MONTHLY_VW_CAP_1963_2024.csv",
               col_types = cols())

# ---- Define sample windows ----
train_start <- 196307
train_end   <- 199407
test_start  <- 199408
test_end    <- 202412

# ---- Original-sample variables (7/1963 to 7/1994) ----
y_original <- df %>%
  filter(date >= train_start, date <= train_end) %>%
  pull(ret)

X_original <- df %>%
  filter(date >= train_start, date <= train_end) %>%
  select(Mkt_RF, SMB, HML, RMW, CMA)

# ---- Replication-sample variables (8/1994 to 12/2024) ----
y_replication <- df %>%
  filter(date >= test_start, date <= test_end) %>%
  pull(ret)

X_replication <- df %>%
  filter(date >= test_start, date <= test_end) %>%
  select(Mkt_RF, SMB, HML, RMW, CMA)

# ---- Posterior Inference ----
log_integrate <- function(f, lower, upper, rel.tol = 1e-12) {
  ## numerically integrate exp(log f) on a log scale
  g <- function(x) exp(f(x))        # recover the original scale for integrate
  stats::integrate(g, lower, upper, rel.tol = rel.tol)$value
}

posterior_null_prob <- function(y, X, pi0 = 0.5, tau = 1) {
  ## 1 — OLS quantities
  y <- as.vector(y);   X <- as.matrix(X)
  Xd <- cbind(1, X)                    # add intercept
  n  <- nrow(Xd);     p  <- ncol(Xd) - 1
  bh <- solve(crossprod(Xd), crossprod(Xd, y))
  resid <- y - Xd %*% bh
  df  <- n - p - 1
  s2  <- sum(resid^2) / df
  Vb  <- s2 * solve(crossprod(Xd))
  b0  <- as.numeric(bh[1]);      se0 <- sqrt(Vb[1,1])
  nu  <- df                      # Student-t df
  
  ## 2 — log-densities
  log_tdens  <- function(b) dt((b - b0)/se0, df = nu, log = TRUE) - log(se0)
  log_prior  <- function(b) log(2) + dnorm(b, sd = tau, log = TRUE)
  
  ## 3 — evidence on each half-line (log-sum-exp inside integrator)
  log_int_fun <- function(side) {
    function(b) log_tdens(b) + log_prior(b)          # log integrand
  }
  E0 <- pi0 * log_integrate(log_int_fun("neg"), -Inf, 0)
  E1 <- (1 - pi0) * log_integrate(log_int_fun("pos"), 0,  Inf)
  
  ## 4 — posterior null probability
  post_M0 <- E0 / (E0 + E1)
  return(post_M0)
}

